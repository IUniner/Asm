.model small
.data
str1 db 13,10,"Enter first number: $"
str2 db 13,10,"Enter second number: $"
n1	dw 0
n2	dw 0
buf1	db 13,10,10 dup('$')
.stack 200h
.code
start:
	mov ax,@data	;настраиваем сегментные регистры
	mov ds,ax
	mov es,ax
	mov dx, offset str1
	call InputNumber
	mov n1,ax
	mov dx, offset str2
	call InputNumber
	mov n2,ax
	add ax,n1
	lea di,buf1+2
	call printdec
	lea dx,buf1+2
	mov ah,9
	int 21h
	
ex:	mov ax,4c00h	;выход из программы
	int 21h


str2dw	proc ;Преобразование строки в число
			
			;на входе ds:si ссылается на ASCIIZ строку, которую нужно преобразовать
			; на выходе в ax - число.
	push bx
	push dx
	push si
	xor bx,bx
	xor dx,dx	;сумма
@lp1:	xor ax,ax
	lodsb		;берем чимвол
	test al,al	;если это нулей байт, то заканчиваем
	jz @ex
	cmp al,'-'	;если минус, то устанавливаем признак минуса
	jnz @m1
	mov bx,1
	jmp @lp1
@m1:	cmp al,'9'	;Если это не цифра, то пропускаем
	jnbe @lp1
	cmp al,'0'      ;Если это не цифра, то пропускаем
	jb @lp1
	sub ax,'0'	;получаем цифровое значение
	shl dx,1	;умножаем сумму на 10
	add ax, dx
	shl dx, 2
	add dx, ax	;прибавляем текущее значение
	jmp @lp1
@ex:	test bx,bx	;если установлен признак отрицательного числа
	jz @ex1
	neg dx		;то меняем знак
@ex1:	mov ax,dx
	pop si
	pop dx
	pop bx
	ret
str2dw	endp
	
InputNum	proc	
			; функция выводит на экран сообщение и ожидает ввода числа
			; ds:dx - сообщение, которое следует вывести
			; возвращает:
			; ax - введенное число
	push dx		; сохраняем регистры
	push si
	push di
	mov ah,9
	
	int 21h
	mov ah,0ah	
	mov dx,offset buf
	int 21h		;пользователь вводит в текстовом виде в buf значение элемента массива
	mov di,offset buf+1
	mov al,[di]	;берем длину введенной строки
	mov ah,0	;ах=длине
	inc di	;начало введенной строки в памяти
	mov si,di		;сохраняем это значение
	add di,ax               ;конец введенной строки в памяти                 
	mov [di],byte ptr 0     ;ставим нулевой байт за последним символом строки
	call str2dw		;преобразовываем строку в значение
	pop di		;восстанавливаем регистры
	pop si
	pop dx
	ret
buf 	db 8, 10 dup(0)	;принимает строку, введенную с клавиатуры
InputNum	endp

InputNumber proc
      push  ebp					; Сохраняем в стеке значение регистра EBP
      mov   ebp, esp				; Заносим в регистр EBP текущее значение вершины стека
      sub   esp, 16				; Резервируем 16 байт. Вводимая строка может содержать до 8 цифр.
						; 2 байта требуются для символов с кодами 13 и 10. Итого 10 байт.
						; 4 байта нужно для целочисленной переменной, куда будет записываться количество
						; введённых символов. Итого 14 байт. Но выделим 16 байт, т.е. 4 двойных слова
      push  ebx					; Сохраняем значения важных регистров
      push  esi
  
  ; Вводим строку
      push  0
      lea   eax, [ebp - 16]			; 4 байта по адресу [EBP – 16] предназначены для хранения количества введённых символов
      push  eax
      push  10d
      lea   eax, [ebp - 12]			; По адресу [EBP – 12] начинается память для вводимой строки
      push  eax
      push  hStdIn
      call  ReadConsole

  ; Преобразуем строку в число
      xor   eax, eax				; Обнуляем регистр EAX ...
      xor   ebx, ebx				; ... и регистр EBX
      mov   ecx, [ebp - 16]			; Заносим в регистр ECX количество введённых символов
      sub   ecx, 2				; Символы с кодами 13 и 10 обрабатывать не надо
      lea   esi, [ebp - 12]			; Заносим в регистр ESI адрес начала строки

      test  ecx, ecx				; Используем команду TEST для сравнения с нулём
      jz    L2					; Если ECX = 0, то завершаем работу процедуры
  L1: mov   bl, [esi]				; Заносим в регистр BL текущий символ (три старших байта EBX
						; содержат 0, т.к. ранее была команда XOR EBX, EBX)
      lea   edx, [ebx - '0']			; Заносим в регистр EDX разность между кодом текущего символа и кодом символа '0'
      cmp   edx, 9				; Сравниваем значение в регистре EDX с 9
      ja    M1					; Если выше, то переходим к следующему сравнению
      sub   bl, '0'				; Иначе получаем число из кода символа
      jmp   M3					; Переходим к действиям, учитывающим текущую цифру
  M1: lea   edx, [ebx - 'a']			; Заносим в регистр EDX разность между кодом текущего символа и кодом символа 'a'
      cmp   edx, 'f' - 'a'			; Сравниваем значение в регистре EDX с 5
      ja    M2					; Если выше, то переходим к следующему сравнению
      sub   bl, 'a' - 10d			; Иначе получаем число из кода символа
      jmp   M3					; Переходим к действиям, учитывающим текущую цифру
  M2: lea   edx, [ebx - 'A'] 			; Заносим в регистр EDX разность между кодом текущего символа и кодом символа 'A'
      cmp   edx, 'F' - 'A'			; Сравниваем значение в регистре EDX с 5
      ja    L2					; Если выше, то завершаем процедуру. Результат не определён,
						; т.к. был введён некорректный символ
      sub   bl, 'A' - 10d			; Иначе получаем число из кода символа
  M3: sal   eax, 4				; Умножаем EAX на 16
      add   eax, ebx				; Прибавляем текущую цифру
      inc   esi					; Переходим к следующему символу
      dec   ecx					; Уменьшаем ECX на 1
      jnz   L1					; Если ECX не равно 0, продолжаем цикл

  L2: pop   esi					; Восстанавливаем значения использовавшихся регистров
      pop   ebx
      mov   esp, ebp				; Освобождаем стек
      pop   ebp					; Восстанавливаем значение регистра EBP
      ret
InputNumber endp

;Процедура вывода числа в 16-ричной системе счисления. Процедура получает один параметр – выводимое число. Для вывода всегда формируется строка из 8-ми шестнадцатеричных цифр с лидирующими нулями. Поскольку количество символов заранее известно, они будут сразу же записываться в строку с конца, и инвертировать строку не придётся. Процедура предназначена для использования в консольном приложении и предполагает, что идентификатор устройства ввода был получен основной программой и сохранён в переменной hStdOut.
digits  db '0123456789abcdef'			; Массив шестнадцатеричных цифр

OutputNumber proc
      push  ebp					; Сохраняем в стеке значение регистра EBP
      mov   ebp, esp				; Заносим в регистр EBP текущее значение вершины стека
      sub   esp, 12				; Выделяем в стеке место под формируемую строку
      push  esi
      
  ; Преобразуем число в строку
      mov   eax, [ebp + 8]			; Заносим в регистр EAX переданный параметр
      mov   ecx, 8				; Заносим в регистр ECX количество символов строки
      mov   byte ptr [ebp - 1], 10		; Добавляем в конец строки символы с кодами 13 и 10 для перевода курсора
      mov   byte ptr [ebp - 2], 13
      lea   esi, [ebp - 3]			; Начиная с адреса [EBP - 3] будут заносится цифры
  L3: mov   edx, eax				; Копируем значение регистра EAX в регистр EDX
      and   edx, 1111b				; Получаем остаток от деления на 16
      shr   eax, 4				; Делим исходное число на 16
      mov   dl, digits[edx]			; По полученному остатку от деления берём цифру ...
      mov   [esi], dl				; ... и записываем её в строку
      dec   esi					; Уменьшаем адрес, т.к. строка формируется с конца
      dec   ecx					; Уменьшаем ECX на 1
      jnz   L3					; Если ECX не равно 0, продолжаем цикл
      
  ; Выводим строку
      inc   esi					; Регистр ESI указывает на начало строки
      push  0
      push  0
      push  10
      push  esi
      push  hStdOut
      call  WriteConsole

      pop   esi
      mov   esp, ebp				; Освобождаем стек
      pop   ebp					; Восстанавливаем значение регистра EBP
      ret   4					; Удаляем из стека переданный параметр и возвращаемся
OutputNumber endp
printdec proc	;преобразование числа из ах в десятичную строку по адресу es:di
		;ax - число
		;es:di - адрес буфера приемника
	push cx	;сохраняем регистры
	push dx
	push bx
	mov bx,10	;основание системы
	XOR CX,CX	;в сх будет количество цифр в десятичном числе
@@m1:	
	XOR dx,dx
	DIV bx		;делим число на степени 10
	PUSH DX		;и сохраняем остаток от деления(коэффициенты при степенях) в стек
	INC CX
	TEST AX,AX
	JNZ @@m1
@@m2:	
	POP AX
	ADD AL,'0'	;преобразовываем число в ASCII символ
	STOSb		;сохраняем в буфер
	LOOP @@m2		;все цифры
	pop bx		;восстанавливаем регистры
	POP dx
	POP cx
	RET
printdec endp


end start

end